[
  {
    "id": "4bea5ea383b8ed08",
    "type": "tab",
    "label": "Cold Path",
    "disabled": false,
    "info": "",
    "env": []
  },
  {
    "id": "0d59331d75d5c423",
    "type": "file in",
    "z": "4bea5ea383b8ed08",
    "name": "read acceleration",
    "filename": "/home/musse/Documents/Class/IOT/Final Project/IoT-Sensor-Data-Processing-NodeRED/batch/accel_data.csv",
    "filenameType": "str",
    "format": "utf8",
    "chunk": false,
    "sendError": false,
    "encoding": "utf8",
    "allProps": false,
    "x": 1710,
    "y": 640,
    "wires": [["2d8e291d34762b33"]]
  },
  {
    "id": "76e1913537c38a55",
    "type": "file in",
    "z": "4bea5ea383b8ed08",
    "name": "read GPS",
    "filename": "/home/musse/Documents/Class/IOT/Final Project/IoT-Sensor-Data-Processing-NodeRED/batch/gps_data.csv",
    "filenameType": "str",
    "format": "utf8",
    "chunk": false,
    "sendError": false,
    "encoding": "utf8",
    "allProps": false,
    "x": 1672,
    "y": 847,
    "wires": [["7e755ee580f15990"]]
  },
  {
    "id": "dcb57e2c35fd1517",
    "type": "file in",
    "z": "4bea5ea383b8ed08",
    "name": "read vital data",
    "filename": "/home/musse/Documents/Class/IOT/Final Project/IoT-Sensor-Data-Processing-NodeRED/batch/vital_data.csv",
    "filenameType": "str",
    "format": "utf8",
    "chunk": false,
    "sendError": false,
    "encoding": "utf8",
    "allProps": false,
    "x": 1700,
    "y": 1040,
    "wires": [["a39f26b70f6a9c31"]]
  },
  {
    "id": "b987eab60af0b60d",
    "type": "inject",
    "z": "4bea5ea383b8ed08",
    "name": "Inject every 1 hour",
    "props": [
      {
        "p": "payload"
      },
      {
        "p": "topic",
        "vt": "str"
      }
    ],
    "repeat": "3600",
    "crontab": "",
    "once": true,
    "onceDelay": 0.1,
    "topic": "",
    "payload": "",
    "payloadType": "date",
    "x": 1100,
    "y": 760,
    "wires": [
      [
        "0d59331d75d5c423",
        "76e1913537c38a55",
        "dcb57e2c35fd1517",
        "5f310965b65d3bfe"
      ]
    ]
  },
  {
    "id": "2d8e291d34762b33",
    "type": "function",
    "z": "4bea5ea383b8ed08",
    "name": "parse acceleration data",
    "func": "var csvData = msg.payload;\nvar lines = csvData.split('\\n');\nvar selectedTeam = global.get('selectedTeam');\n\n// Initialize an array to hold the processed data\nvar processedData = [];\n\n// Iterate over each line of the CSV\nfor (var i = 1; i < lines.length; i++) {\n    var line = lines[i].trim();\n    if (line === '') continue; // Skip empty lines\n\n    var values = line.split(',');\n    var data = {};\n\n    // Assuming the CSV format: timestamp,timestampRegular,sensor_id,sensor_team,x,y,z\n    data.timestamp = values[0].trim();\n    data.timestampRegular = parseInt(values[1].trim(), 10); // Assuming timestampRegular is an integer\n    data.sensor_id = values[2].trim();\n    data.sensor_team = values[3].trim();\n    data.x = parseFloat(values[4].trim());\n    data.y = parseFloat(values[5].trim());\n    data.z = parseFloat(values[6].trim());\n\n    // Check for valid x, y, z values\n    if (!isNaN(data.x) && !isNaN(data.y) && !isNaN(data.z)) {\n        // Calculate magnitude\n        data.magnitude = Math.sqrt(data.x * data.x + data.y * data.y + data.z * data.z);\n\n        if (selectedTeam !== \"all\" && selectedTeam != null && selectedTeam != undefined) {\n            if (data.sensor_team === selectedTeam) {\n                processedData.push(data);\n            }\n        } else {\n            processedData.push(data);\n        }\n    }\n}\n\n// Set the processed data as the message payload\nmsg.payload = processedData;\n\nreturn msg;\n",
    "outputs": 1,
    "timeout": 0,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 2000,
    "y": 640,
    "wires": [["fce6969a1e46eebd", "cb5156b336cf9a23"]]
  },
  {
    "id": "a2ce6f5448ee0636",
    "type": "ui_chart",
    "z": "4bea5ea383b8ed08",
    "name": "magnitude chart",
    "group": "7b778c48129e069b",
    "order": 7,
    "width": 7,
    "height": 4,
    "label": "Magnitude Chart",
    "chartType": "line",
    "legend": "false",
    "xformat": "HH:mm:ss",
    "interpolate": "linear",
    "nodata": "",
    "dot": false,
    "ymin": "",
    "ymax": "",
    "removeOlder": 1,
    "removeOlderPoints": "",
    "removeOlderUnit": "1",
    "cutout": 0,
    "useOneColor": false,
    "useUTC": false,
    "colors": [
      "#189a51",
      "#dcafe9",
      "#ff7f0e",
      "#197619",
      "#98df8a",
      "#d62728",
      "#ff9896",
      "#9467bd",
      "#c5b0d5"
    ],
    "outputs": 1,
    "useDifferentColor": false,
    "className": "",
    "x": 2632,
    "y": 580,
    "wires": [[]]
  },
  {
    "id": "fce6969a1e46eebd",
    "type": "function",
    "z": "4bea5ea383b8ed08",
    "name": "setting magnitude payload",
    "func": "var processedData = msg.payload;\n\n// Initialize an array to hold the data for the chart\nvar chartData = [];\n\n// Iterate over the processed data to extract timestamp and magnitude\nfor (var i = 0; i < processedData.length; i++) {\n    var data = processedData[i];\n\n    // Only process entries with calculated magnitude\n    if (data.magnitude !== undefined) {\n        chartData.push({\n            x: new Date(data.timestamp),\n            y: data.magnitude\n        });\n    }\n}\n\n// Set the processed data for the chart as the message payload\nmsg.payload = [{\n    series: [\"Magnitude\"],\n    data: [chartData],\n    labels: [\"\"]\n}];\n\nreturn msg;\n",
    "outputs": 1,
    "timeout": 0,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 2352,
    "y": 580,
    "wires": [["a2ce6f5448ee0636"]]
  },
  {
    "id": "7e755ee580f15990",
    "type": "function",
    "z": "4bea5ea383b8ed08",
    "name": "parse GPS data",
    "func": "var csvData = msg.payload;\nvar lines = csvData.split('\\n');\nvar selectedTeam = global.get('selectedTeam');\n\n// Initialize an array to hold the processed data\nvar processedData = [];\n\n// Iterate over each line of the CSV\nfor (var i = 1; i < lines.length; i++) {\n    var line = lines[i].trim();\n    if (line === '') continue; // Skip empty lines\n\n    var values = line.split(',');\n    var data = {};\n\n    // Assuming the CSV format: timestamp,timestampRegular,sensor_id,sensor_team,latitude,longitude\n    data.timestamp = values[0].trim();\n    data.timestampRegular = parseInt(values[1].trim(), 10); // Assuming timestampRegular is an integer\n    data.sensor_id = values[2].trim();\n    data.sensor_team = values[3].trim();\n    data.latitude = parseFloat(values[4].trim());\n    data.longitude = parseFloat(values[5].trim());\n\n    if (!isNaN(data.latitude) && !isNaN(data.longitude)) {\n        if (selectedTeam !== \"all\" && selectedTeam != null && selectedTeam != undefined) {\n            if (data.sensor_team === selectedTeam) {\n                processedData.push(data);\n            }\n        } else {\n            processedData.push(data);\n        }\n    }\n}\n\n// Set the processed data as the message payload\nmsg.payload = processedData;\n\nreturn msg;\n",
    "outputs": 1,
    "timeout": 0,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 1952,
    "y": 847,
    "wires": [["d09c7cf6d32e47ff", "f04324ee9dbe32c2"]]
  },
  {
    "id": "974bbdf1173c2e81",
    "type": "ui_worldmap",
    "z": "4bea5ea383b8ed08",
    "group": "7b778c48129e069b",
    "order": 20,
    "width": 17,
    "height": 5,
    "name": "GPS Map",
    "lat": "",
    "lon": "",
    "zoom": "",
    "layer": "OSMG",
    "cluster": "",
    "maxage": "",
    "usermenu": "hide",
    "layers": "hide",
    "panit": "false",
    "panlock": "false",
    "zoomlock": "false",
    "hiderightclick": "true",
    "coords": "none",
    "showgrid": "false",
    "showruler": "false",
    "allowFileDrop": "false",
    "path": "/worldmap2",
    "overlist": "DR,CO,RA,DN,HM",
    "maplist": "OSMG,OSMC,EsriC,EsriS,EsriT,EsriDG,UKOS",
    "mapname": "",
    "mapurl": "",
    "mapopt": "",
    "mapwms": false,
    "x": 2532,
    "y": 807,
    "wires": []
  },
  {
    "id": "d09c7cf6d32e47ff",
    "type": "function",
    "z": "4bea5ea383b8ed08",
    "name": "prepare for GPS Map",
    "func": "// Iterate over each GPS data point\nfor (var i = 0; i < msg.payload.length; i++) {\n    var data = {\n        name:msg.payload[i].sensor_team +  \" point \" + (i + 1),     // Unique name for each point\n        lat: msg.payload[i].latitude, // Latitude of the point\n        lon: msg.payload[i].longitude // Longitude of the point\n        // Optionally, you can add more properties like icon and layer\n    };\n\n    // Emit each data point individually to the Worldmap node\n    node.send({\n        payload: data\n    });\n}\n\nreturn null; // Return null to suppress the original message\n",
    "outputs": 1,
    "timeout": 0,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 2312,
    "y": 807,
    "wires": [["974bbdf1173c2e81"]]
  },
  {
    "id": "f04324ee9dbe32c2",
    "type": "function",
    "z": "4bea5ea383b8ed08",
    "name": "distance calculation",
    "func": "var gpsData = msg.payload;\nvar selectedTeam = global.get('selectedTeam');\nvar teamDistances = {};\nvar totalDistance = 0;\n\n// Helper function to calculate distance using Haversine formula\nfunction haversineDistance(lat1, lon1, lat2, lon2) {\n    var R = 6371000; // Radius of the Earth in meters\n    var phi1 = toRadians(lat1);\n    var phi2 = toRadians(lat2);\n    var deltaPhi = toRadians(lat2 - lat1);\n    var deltaLambda = toRadians(lon2 - lon1);\n\n    var a = Math.sin(deltaPhi / 2) * Math.sin(deltaPhi / 2) +\n        Math.cos(phi1) * Math.cos(phi2) *\n        Math.sin(deltaLambda / 2) * Math.sin(deltaLambda / 2);\n    var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n\n    return R * c; // Distance in meters\n}\n\nfunction toRadians(degrees) {\n    return degrees * Math.PI / 180;\n}\n\n// Process distances based on the selected team\nif (selectedTeam !== \"all\") {\n    // Calculate distance for the selected team only\n    for (var i = 1; i < gpsData.length; i++) {\n        var prevPoint = gpsData[i - 1];\n        var currPoint = gpsData[i];\n\n        var distance = haversineDistance(prevPoint.latitude, prevPoint.longitude, currPoint.latitude, currPoint.longitude);\n        totalDistance += distance;\n    }\n    totalDistance = totalDistance / 1000; // Convert to kilometers\n    msg.payload = totalDistance.toFixed(2) + \" km\"; // Format the payload as a string with two decimal places\n\n} else {\n    // Group data by sensor_team and calculate distances\n    gpsData.forEach(function(data) {\n        if (!teamDistances[data.sensor_team]) {\n            teamDistances[data.sensor_team] = 0;\n        }\n    });\n\n    for (var team in teamDistances) {\n        var teamData = gpsData.filter(point => point.sensor_team === team);\n        var teamDistance = 0;\n\n        for (var i = 1; i < teamData.length; i++) {\n            var prevPoint = teamData[i - 1];\n            var currPoint = teamData[i];\n\n            var distance = haversineDistance(prevPoint.latitude, prevPoint.longitude, currPoint.latitude, currPoint.longitude);\n            teamDistance += distance;\n        }\n\n        teamDistances[team] = teamDistance / 1000; // Convert to kilometers\n        totalDistance += teamDistances[team]; // Sum up the distance for all teams\n    }\n\n    msg.payload = totalDistance.toFixed(2) + \" km\"; // Format as a string with two decimal places\n}\n\nreturn msg;\n",
    "outputs": 1,
    "timeout": 0,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 2292,
    "y": 867,
    "wires": [["b5fa3c37e91546a7"]]
  },
  {
    "id": "b5fa3c37e91546a7",
    "type": "ui_text",
    "z": "4bea5ea383b8ed08",
    "group": "7b778c48129e069b",
    "order": 22,
    "width": 7,
    "height": 3,
    "name": "",
    "label": "Distance traveled",
    "format": "{{msg.payload}}",
    "layout": "row-spread",
    "className": "",
    "style": false,
    "font": "",
    "fontSize": 16,
    "color": "#000000",
    "x": 2592,
    "y": 867,
    "wires": []
  },
  {
    "id": "a39f26b70f6a9c31",
    "type": "function",
    "z": "4bea5ea383b8ed08",
    "name": "parse vital data",
    "func": "var csvData = msg.payload;\nvar lines = csvData.split('\\n');\nvar selectedTeam = global.get('selectedTeam');\n\n// Initialize an array to hold the processed data\nvar processedData = [];\n\n// Iterate over each line of the CSV, starting from the second line to skip the header\nfor (var i = 1; i < lines.length; i++) {\n    var line = lines[i].trim();\n    if (line === '') continue; // Skip empty lines\n\n    var values = line.split(',');\n    var data = {};\n\n    // Assuming the CSV format: timestamp,timestampRegular,sensor_id,sensor_team,heart_rate,body_temperature\n    data.timestamp = values[0].trim();\n    data.timestampRegular = parseInt(values[1].trim(), 10); // Assuming timestampRegular is an integer\n    data.sensor_id = values[2].trim();\n    data.sensor_team = values[3].trim();\n    data.heart_rate = parseInt(values[4].trim(), 10);\n    data.body_temperature = parseFloat(values[5].trim());\n\n    // Check for valid heart_rate and body_temperature values\n    if (!isNaN(data.heart_rate) && !isNaN(data.body_temperature)) {\n        if (selectedTeam !== \"all\" && selectedTeam != null && selectedTeam != undefined) {\n            if (data.sensor_team === selectedTeam) {\n                processedData.push(data);\n            }\n        } else {\n            processedData.push(data);\n        }\n    }\n}\n\n// Set the processed data as the message payload\nmsg.payload = processedData;\nreturn msg;\n",
    "outputs": 1,
    "timeout": 0,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 1920,
    "y": 1040,
    "wires": [["ac1a7110f3460241", "962851fdd4f6580c", "a3bc0a042a7d5053"]]
  },
  {
    "id": "ac1a7110f3460241",
    "type": "function",
    "z": "4bea5ea383b8ed08",
    "name": "prepare heart rate for line chart",
    "func": "var processedData = msg.payload;\n\n// Initialize arrays to hold the data for the heart rate chart\nvar heartRateData = [];\n\n// Iterate over the processed data to extract timestamp and heart rate\nfor (var i = 0; i < processedData.length; i++) {\n    var data = processedData[i];\n\n    // Prepare data for heart rate chart\n    heartRateData.push({\n        x: new Date(data.timestamp),\n        y: data.heart_rate\n    });\n}\n\n// Set the processed heart rate data as the message payload\nmsg.payload = [{\n    series: [\"Heart Rate\"],\n    data: [heartRateData],\n    labels: [\"\"]\n}];\n\nreturn msg;\n",
    "outputs": 1,
    "timeout": 0,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 2312,
    "y": 994,
    "wires": [["cea815c7512eefc4"]]
  },
  {
    "id": "cea815c7512eefc4",
    "type": "ui_chart",
    "z": "4bea5ea383b8ed08",
    "name": "",
    "group": "7b778c48129e069b",
    "order": 29,
    "width": 8,
    "height": 8,
    "label": "heart rate chart",
    "chartType": "line",
    "legend": "false",
    "xformat": "HH:mm:ss",
    "interpolate": "linear",
    "nodata": "",
    "dot": false,
    "ymin": "",
    "ymax": "",
    "removeOlder": 1,
    "removeOlderPoints": "",
    "removeOlderUnit": "3600",
    "cutout": 0,
    "useOneColor": false,
    "useUTC": false,
    "colors": [
      "#1f77b4",
      "#aec7e8",
      "#ff7f0e",
      "#2ca02c",
      "#98df8a",
      "#d62728",
      "#ff9896",
      "#9467bd",
      "#c5b0d5"
    ],
    "outputs": 1,
    "useDifferentColor": false,
    "className": "",
    "x": 2592,
    "y": 994,
    "wires": [[]]
  },
  {
    "id": "962851fdd4f6580c",
    "type": "function",
    "z": "4bea5ea383b8ed08",
    "name": "prepare body temprature for line chart",
    "func": "var processedData = msg.payload;\n\n// Initialize array to hold the data for the body temperature chart\nvar bodyTemperatureData = [];\n\n// Iterate over the processed data to extract timestamp and body temperature\nfor (var i = 0; i < processedData.length; i++) {\n    var data = processedData[i];\n\n    // Prepare data for body temperature chart\n    bodyTemperatureData.push({\n        x: new Date(data.timestamp),\n        y: data.body_temperature\n    });\n}\n\n// Set the processed body temperature data as the message payload\nmsg.payload = [{\n    series: [\"Body Temperature\"],\n    data: [bodyTemperatureData],\n    labels: [\"\"]\n}];\n\nreturn msg;\n",
    "outputs": 1,
    "timeout": 0,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 2352,
    "y": 1054,
    "wires": [["41efe0f49e6bea24"]]
  },
  {
    "id": "41efe0f49e6bea24",
    "type": "ui_chart",
    "z": "4bea5ea383b8ed08",
    "name": "",
    "group": "7b778c48129e069b",
    "order": 28,
    "width": 8,
    "height": 8,
    "label": "body temprature chart",
    "chartType": "line",
    "legend": "false",
    "xformat": "HH:mm:ss",
    "interpolate": "linear",
    "nodata": "",
    "dot": false,
    "ymin": "",
    "ymax": "",
    "removeOlder": 1,
    "removeOlderPoints": "",
    "removeOlderUnit": "3600",
    "cutout": 0,
    "useOneColor": false,
    "useUTC": false,
    "colors": [
      "#1f77b4",
      "#aec7e8",
      "#ff7f0e",
      "#2ca02c",
      "#98df8a",
      "#d62728",
      "#ff9896",
      "#9467bd",
      "#c5b0d5"
    ],
    "outputs": 1,
    "useDifferentColor": false,
    "className": "",
    "x": 2680,
    "y": 1060,
    "wires": [[]]
  },
  {
    "id": "a3bc0a042a7d5053",
    "type": "function",
    "z": "4bea5ea383b8ed08",
    "name": "statistical analysis for vital data",
    "func": "var processedData = msg.payload;\n\n// Initialize arrays to hold heart rate and body temperature data\nvar heartRates = [];\nvar bodyTemperatures = [];\n\n// Iterate over processed data to extract heart rates and body temperatures\nfor (var i = 0; i < processedData.length; i++) {\n    var data = processedData[i];\n\n    // Check if heart_rate is a valid number before collecting it\n    if (!isNaN(data.heart_rate)) {\n        heartRates.push(data.heart_rate);\n    }\n\n    // Check if body_temperature is a valid number before collecting it\n    if (!isNaN(data.body_temperature)) {\n        bodyTemperatures.push(data.body_temperature);\n    }\n}\n\n// Calculate average heart rate if the array is not empty\nvar averageHeartRate = heartRates.length > 0 ? \n    (heartRates.reduce((acc, val) => acc + val, 0) / heartRates.length).toFixed(2) : \n    \"N/A\";\n\n// Calculate maximum and minimum heart rate if the array is not empty\nvar maxHeartRate = heartRates.length > 0 ? Math.max(...heartRates) : \"N/A\";\nvar minHeartRate = heartRates.length > 0 ? Math.min(...heartRates) : \"N/A\";\n\n// Calculate average body temperature if the array is not empty\nvar averageBodyTemperature = bodyTemperatures.length > 0 ? \n    (bodyTemperatures.reduce((acc, val) => acc + val, 0) / bodyTemperatures.length).toFixed(2) : \n    \"N/A\";\n\n// Calculate maximum and minimum body temperature if the array is not empty\nvar maxBodyTemperature = bodyTemperatures.length > 0 ? Math.max(...bodyTemperatures).toFixed(2) : \"N/A\";\nvar minBodyTemperature = bodyTemperatures.length > 0 ? Math.min(...bodyTemperatures).toFixed(2) : \"N/A\";\n\n// Prepare the payload with calculated statistics\nmsg.payload = {\n    averageHeartRate: averageHeartRate,\n    maxHeartRate: maxHeartRate,\n    minHeartRate: minHeartRate,\n    averageBodyTemperature: averageBodyTemperature,\n    maxBodyTemperature: maxBodyTemperature,\n    minBodyTemperature: minBodyTemperature\n};\n\nreturn msg;\n",
    "outputs": 1,
    "timeout": 0,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 2312,
    "y": 1114,
    "wires": [["4584460794e6cea8"]]
  },
  {
    "id": "4584460794e6cea8",
    "type": "ui_template",
    "z": "4bea5ea383b8ed08",
    "group": "7b778c48129e069b",
    "name": "vital data statistical analysis template",
    "order": 39,
    "width": 8,
    "height": 5,
    "format": "<h2>Vital Statistics</h2>\n<div>\n    <p><strong>Average Heart Rate:</strong> {{msg.payload.averageHeartRate}} bpm</p>\n    <p><strong>Maximum Heart Rate:</strong> {{msg.payload.maxHeartRate}} bpm</p>\n    <p><strong>Minimum Heart Rate:</strong> {{msg.payload.minHeartRate}} bpm</p>\n    <p><strong>Average Body Temperature:</strong> {{msg.payload.averageBodyTemperature}} °C</p>\n    <p><strong>Maximum Body Temperature:</strong> {{msg.payload.maxBodyTemperature}} °C</p>\n    <p><strong>Minimum Body Temperature:</strong> {{msg.payload.minBodyTemperature}} °C</p>\n</div>",
    "storeOutMessages": true,
    "fwdInMessages": true,
    "resendOnRefresh": true,
    "templateScope": "local",
    "className": "",
    "x": 2732,
    "y": 1114,
    "wires": [[]]
  },
  {
    "id": "8e3b01c70cdd5e5f",
    "type": "ui_dropdown",
    "z": "4bea5ea383b8ed08",
    "name": "",
    "label": "Select Team",
    "tooltip": "",
    "place": "Select Team",
    "group": "7b778c48129e069b",
    "order": 2,
    "width": 7,
    "height": 2,
    "passthru": true,
    "multiple": false,
    "options": [
      {
        "label": "All teams",
        "value": "all",
        "type": "str"
      },
      {
        "label": "Team 1",
        "value": "team_1",
        "type": "str"
      },
      {
        "label": "Team 2",
        "value": "team_2",
        "type": "str"
      },
      {
        "label": "Team 3",
        "value": "team_3",
        "type": "str"
      }
    ],
    "payload": "",
    "topic": "payload",
    "topicType": "msg",
    "className": "",
    "x": 1090,
    "y": 920,
    "wires": [["f910b6aaa8602445"]]
  },
  {
    "id": "f910b6aaa8602445",
    "type": "function",
    "z": "4bea5ea383b8ed08",
    "name": "save selected team to global context",
    "func": "// Function node to handle team selection from the dropdown\nvar teamId = msg.payload;\nglobal.set(\"selectedTeam\", teamId);\nreturn msg;\n",
    "outputs": 1,
    "timeout": 0,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 1100,
    "y": 980,
    "wires": [["ded6b1f38b72788d"]]
  },
  {
    "id": "ded6b1f38b72788d",
    "type": "function",
    "z": "4bea5ea383b8ed08",
    "name": "get selected team from global context",
    "func": "var teamId = global.get(\"selectedTeam\");\nmsg.payload = teamId;\nreturn msg;",
    "outputs": 1,
    "timeout": 0,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 1100,
    "y": 1040,
    "wires": [["e293402513b245f4"]]
  },
  {
    "id": "e293402513b245f4",
    "type": "trigger",
    "z": "4bea5ea383b8ed08",
    "name": "Trigger reading on team change",
    "op1": "0",
    "op2": "0",
    "op1type": "str",
    "op2type": "str",
    "duration": "250",
    "extend": false,
    "overrideDelay": false,
    "units": "ms",
    "reset": "",
    "bytopic": "all",
    "topic": "topic",
    "outputs": 1,
    "x": 1100,
    "y": 1100,
    "wires": [
      [
        "0d59331d75d5c423",
        "76e1913537c38a55",
        "dcb57e2c35fd1517",
        "5f310965b65d3bfe"
      ]
    ]
  },
  {
    "id": "5f310965b65d3bfe",
    "type": "file in",
    "z": "4bea5ea383b8ed08",
    "name": "read speed",
    "filename": "/home/musse/Documents/Class/IOT/Final Project/IoT-Sensor-Data-Processing-NodeRED/batch/speed_data.csv",
    "filenameType": "str",
    "format": "utf8",
    "chunk": false,
    "sendError": false,
    "encoding": "utf8",
    "allProps": false,
    "x": 1692,
    "y": 1240,
    "wires": [["325cc46b0a77ce7b"]]
  },
  {
    "id": "325cc46b0a77ce7b",
    "type": "function",
    "z": "4bea5ea383b8ed08",
    "name": "parse speed data",
    "func": "var csvData = msg.payload;\nvar lines = csvData.split('\\n');\nvar selectedTeam = global.get('selectedTeam');\n\n// Initialize an array to hold the processed data\nvar processedData = [];\n\n// Iterate over each line of the CSV, starting from the second line to skip the header\nfor (var i = 1; i < lines.length; i++) {\n    var line = lines[i].trim();\n    if (line === '') continue; // Skip empty lines\n\n    var values = line.split(',');\n    var data = {};\n\n    // Assuming the CSV format: timestamp,timestampRegular,sensor_id,sensor_team,speed\n    data.timestamp = values[0].trim();\n    data.timestampRegular = parseInt(values[1].trim(), 10); // Assuming timestampRegular is an integer\n    data.sensor_id = values[2].trim();\n    data.sensor_team = values[3].trim();\n    data.speed = parseFloat(values[4].trim());\n\n    // Validate the parsed values\n    if (!isNaN(data.timestampRegular) && !isNaN(data.speed)) {\n        if (selectedTeam !== \"all\" && selectedTeam != null && selectedTeam != undefined) {\n            if (data.sensor_team === selectedTeam) {\n                processedData.push(data);\n            }\n        } else {\n            processedData.push(data);\n        }\n    }\n}\n\n// Set the processed data as the message payload\nmsg.payload = processedData;\n\nreturn msg;\n",
    "outputs": 1,
    "timeout": 0,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 1972,
    "y": 1240,
    "wires": [
      [
        "5653ef41c8e1ae00",
        "3d9302fa305818c9",
        "c69c70aa657ee55f",
        "f0c0954d8de15d69"
      ]
    ]
  },
  {
    "id": "5653ef41c8e1ae00",
    "type": "function",
    "z": "4bea5ea383b8ed08",
    "name": "calculate basic speed statistics",
    "func": "var speedData = msg.payload;\n\n// Initialize variables for calculations\nvar sumSpeed = 0;\nvar maxSpeed = -Infinity;\nvar minSpeed = Infinity;\nvar speedValues = [];\n\n// Iterate over speed data to collect statistics\nfor (var i = 0; i < speedData.length; i++) {\n    var speed = speedData[i].speed;\n\n    // Sum for average calculation\n    sumSpeed += speed;\n\n    // Check for max speed\n    if (speed > maxSpeed) {\n        maxSpeed = speed;\n    }\n\n    // Check for min speed\n    if (speed < minSpeed) {\n        minSpeed = speed;\n    }\n\n    // Collect speeds for standard deviation calculation\n    speedValues.push(speed);\n}\n\n// Calculate average speed\nvar averageSpeed = sumSpeed / speedData.length;\n\n// Calculate standard deviation\nvar mean = averageSpeed;\nvar sumSquaredDiffs = speedValues.reduce((acc, val) => acc + Math.pow(val - mean, 2), 0);\nvar standardDeviation = Math.sqrt(sumSquaredDiffs / speedValues.length);\n\n// Prepare the payload with calculated statistics\nmsg.payload = {\n    averageSpeed: averageSpeed.toFixed(2),\n    maxSpeed: maxSpeed.toFixed(2),\n    minSpeed: minSpeed.toFixed(2),\n    standardDeviation: standardDeviation.toFixed(2)\n};\n\nreturn msg;\n",
    "outputs": 1,
    "timeout": 0,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 2332,
    "y": 1277,
    "wires": [["6d11f1dfb4b1ee1b"]]
  },
  {
    "id": "3d9302fa305818c9",
    "type": "function",
    "z": "4bea5ea383b8ed08",
    "name": "prepare speed for line chart",
    "func": "var processedData = msg.payload;\n\n// Initialize an array to hold the data for the speed chart\nvar speedData = [];\n\n// Iterate over the processed data to extract timestamp and speed\nfor (var i = 0; i < processedData.length; i++) {\n    var data = processedData[i];\n\n    // Prepare data for speed chart\n    speedData.push({\n        x: new Date(data.timestamp),\n        y: data.speed\n    });\n}\n\n// Set the processed speed data as the message payload\nmsg.payload = [{\n    series: [\"Speed\"],\n    data: [speedData],\n    labels: [\"\"]\n}];\n\nreturn msg;\n",
    "outputs": 1,
    "timeout": 0,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 2320,
    "y": 1220,
    "wires": [["651758408958ee7a"]]
  },
  {
    "id": "651758408958ee7a",
    "type": "ui_chart",
    "z": "4bea5ea383b8ed08",
    "name": "",
    "group": "7b778c48129e069b",
    "order": 19,
    "width": 17,
    "height": 6,
    "label": "speed chart",
    "chartType": "line",
    "legend": "false",
    "xformat": "HH:mm:ss",
    "interpolate": "linear",
    "nodata": "",
    "dot": false,
    "ymin": "",
    "ymax": "",
    "removeOlder": 1,
    "removeOlderPoints": "",
    "removeOlderUnit": "3600",
    "cutout": 0,
    "useOneColor": false,
    "useUTC": false,
    "colors": [
      "#1f77b4",
      "#aec7e8",
      "#ff7f0e",
      "#2ca02c",
      "#98df8a",
      "#d62728",
      "#ff9896",
      "#9467bd",
      "#c5b0d5"
    ],
    "outputs": 1,
    "useDifferentColor": false,
    "className": "",
    "x": 2572,
    "y": 1217,
    "wires": [[]]
  },
  {
    "id": "6d11f1dfb4b1ee1b",
    "type": "ui_template",
    "z": "4bea5ea383b8ed08",
    "group": "7b778c48129e069b",
    "name": "speed statistics template",
    "order": 17,
    "width": 6,
    "height": 4,
    "format": "<!-- UI Template Node for Displaying Speed Statistics -->\n<div style=\"text-align: center;\">\n    <h2>Speed Statistics</h2>\n    <p><strong>Average Speed:</strong> {{msg.payload.averageSpeed}} m/s</p>\n    <p><strong>Max Speed:</strong> {{msg.payload.maxSpeed}} m/s</p>\n    <p><strong>Min Speed:</strong> {{msg.payload.minSpeed}} m/s</p>\n    <p><strong>Standard Deviation:</strong> {{msg.payload.standardDeviation}} m/s</p>\n</div>",
    "storeOutMessages": true,
    "fwdInMessages": true,
    "resendOnRefresh": true,
    "templateScope": "local",
    "className": "",
    "x": 2670,
    "y": 1280,
    "wires": [[]]
  },
  {
    "id": "c69c70aa657ee55f",
    "type": "function",
    "z": "4bea5ea383b8ed08",
    "name": "average speed by hour",
    "func": "var speedData = msg.payload;\nvar hourlySpeeds = {};\n\n// Aggregate speeds by hour\nfor (var i = 0; i < speedData.length; i++) {\n    var timestamp = new Date(speedData[i].timestamp);\n    var hour = timestamp.getUTCHours();\n    if (!hourlySpeeds[hour]) {\n        hourlySpeeds[hour] = { sumSpeed: 0, count: 0 };\n    }\n    hourlySpeeds[hour].sumSpeed += speedData[i].speed;\n    hourlySpeeds[hour].count += 1;\n}\n\n// Calculate average speed for each hour\nvar averageHourlySpeeds = [];\nfor (var hourStr in hourlySpeeds) {\n    var hour = parseInt(hourStr); // Ensure hour is treated as a number\n    var avgSpeed = hourlySpeeds[hour].sumSpeed / hourlySpeeds[hour].count;\n    averageHourlySpeeds.push({ hour: hour, averageSpeed: avgSpeed.toFixed(2) });\n}\n\n// Set the average hourly speeds as the message payload\nmsg.payload = averageHourlySpeeds;\n\nreturn msg;\n",
    "outputs": 1,
    "timeout": 0,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 2300,
    "y": 1340,
    "wires": [["12bfad145cb51346"]]
  },
  {
    "id": "12bfad145cb51346",
    "type": "ui_template",
    "z": "4bea5ea383b8ed08",
    "group": "7b778c48129e069b",
    "name": "average speed by hour template",
    "order": 18,
    "width": 5,
    "height": 4,
    "format": "<table style=\"width:100%; border: 1px solid black; border-collapse: collapse;\">\n    <tr>\n        <th style=\"border: 1px solid black; padding: 5px;\">Hour</th>\n        <th style=\"border: 1px solid black; padding: 5px;\">Average Speed (km/h)</th>\n    </tr>\n    <tr ng-repeat=\"item in msg.payload\">\n        <td style=\"border: 1px solid black; padding: 5px;\">{{ item.hour }}</td>\n        <td style=\"border: 1px solid black; padding: 5px;\">{{ item.averageSpeed }}</td>\n    </tr>\n</table>",
    "storeOutMessages": true,
    "fwdInMessages": true,
    "resendOnRefresh": true,
    "templateScope": "local",
    "className": "",
    "x": 2700,
    "y": 1340,
    "wires": [[]]
  },
  {
    "id": "f0c0954d8de15d69",
    "type": "function",
    "z": "4bea5ea383b8ed08",
    "name": "activity recognition (threshold-based)",
    "func": "// Function node for activity recognition (threshold-based)\nvar data = msg.payload;\n\n// Initialize counters for each activity\nvar walkingCount = 0;\nvar runningCount = 0;\nvar sprintingCount = 0;\n\n// Realistic thresholds based on typical speed ranges (m/s)\nvar walkingThreshold = 8;  // Speed < 8 m/s for walking\nvar runningThreshold = 16;  // Speed between 8 and 16 m/s for running\n\nfor (var i = 0; i < data.length; i++) {\n    var speed = parseFloat(data[i].speed);\n    \n    // Classify activities based on thresholds\n    if (speed < walkingThreshold) {\n        data[i].activity = \"Walking\";\n        walkingCount++;\n    } else if (speed >= walkingThreshold && speed < runningThreshold) {\n        data[i].activity = \"Running\";\n        runningCount++;\n    } else {\n        data[i].activity = \"Sprinting\";\n        sprintingCount++;\n    }\n}\n\n// Calculate percentages\nvar totalCount = walkingCount + runningCount + sprintingCount;\nvar walkingPercentage = (totalCount > 0) ? (walkingCount / totalCount) * 100 : 0;\nvar runningPercentage = (totalCount > 0) ? (runningCount / totalCount) * 100 : 0;\nvar sprintingPercentage = (totalCount > 0) ? (sprintingCount / totalCount) * 100 : 0;\n\n// Add the counts and percentages to the message payload\nmsg.payload = {\n    data: data,\n    counts: {\n        walking: walkingCount,\n        running: runningCount,\n        sprinting: sprintingCount\n    },\n    percentages: {\n        walking: walkingPercentage.toFixed(2),\n        running: runningPercentage.toFixed(2),\n        sprinting: sprintingPercentage.toFixed(2)\n    }\n};\n\nreturn msg;\n",
    "outputs": 1,
    "timeout": 0,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 2380,
    "y": 1480,
    "wires": [["3703c8173dc02e99", "b2dfcb5b2e657521", "ce7f545fa342c473"]]
  },
  {
    "id": "190389dd2e540d70",
    "type": "ui_chart",
    "z": "4bea5ea383b8ed08",
    "name": "speed activity distribution",
    "group": "7b778c48129e069b",
    "order": 16,
    "width": 6,
    "height": 4,
    "label": "Speed Activity Distribution",
    "chartType": "pie",
    "legend": "true",
    "xformat": "HH:mm:ss",
    "interpolate": "linear",
    "nodata": "",
    "dot": false,
    "ymin": "",
    "ymax": "",
    "removeOlder": 1,
    "removeOlderPoints": "",
    "removeOlderUnit": "3600",
    "cutout": 0,
    "useOneColor": false,
    "useUTC": false,
    "colors": [
      "#195886",
      "#3c7317",
      "#fd6a08",
      "#2ca02c",
      "#98df8a",
      "#d62728",
      "#ff9896",
      "#9467bd",
      "#c5b0d5"
    ],
    "outputs": 1,
    "useDifferentColor": false,
    "className": "",
    "x": 3088,
    "y": 1480,
    "wires": [[]]
  },
  {
    "id": "ce7f545fa342c473",
    "type": "function",
    "z": "4bea5ea383b8ed08",
    "name": "prepare sprinting data for pie chart",
    "func": "// Function node to prepare data for the pie chart\nvar percentages = msg.payload.percentages;\n\nmsg.payload = percentages.sprinting;\nmsg.topic = \"Sprinting\";\n\nreturn msg;\n",
    "outputs": 1,
    "timeout": 0,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 2740,
    "y": 1540,
    "wires": [["190389dd2e540d70"]]
  },
  {
    "id": "3703c8173dc02e99",
    "type": "function",
    "z": "4bea5ea383b8ed08",
    "name": "prepare walking data for pie chart",
    "func": "// Function node to prepare data for the pie chart\nvar percentages = msg.payload.percentages;\n\nmsg.payload = percentages.walking;\nmsg.topic = \"Walking\";\n\nreturn msg;\n",
    "outputs": 1,
    "timeout": 0,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 2740,
    "y": 1420,
    "wires": [["190389dd2e540d70"]]
  },
  {
    "id": "b2dfcb5b2e657521",
    "type": "function",
    "z": "4bea5ea383b8ed08",
    "name": "prepare running data for pie chart",
    "func": "// Function node to prepare data for the pie chart\nvar percentages = msg.payload.percentages;\n\nmsg.payload = percentages.running;\nmsg.topic = \"Running\";\n\nreturn msg;\n",
    "outputs": 1,
    "timeout": 0,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 2740,
    "y": 1480,
    "wires": [["190389dd2e540d70"]]
  },
  {
    "id": "cb5156b336cf9a23",
    "type": "function",
    "z": "4bea5ea383b8ed08",
    "name": "statstical analysis for acceleration data",
    "func": "// Function node for statistical analysis\nvar data = msg.payload;\n\n// Helper function to calculate median\nfunction median(values) {\n    if (values.length === 0) return 0;\n    values.sort(function(a, b) {\n        return a - b;\n    });\n    var half = Math.floor(values.length / 2);\n    if (values.length % 2) {\n        return values[half];\n    } else {\n        return (values[half - 1] + values[half]) / 2.0;\n    }\n}\n\n// Initialize arrays to hold values for each axis and magnitude\nvar xValues = [];\nvar yValues = [];\nvar zValues = [];\nvar magnitudeValues = [];\n\n// Populate arrays with data\nfor (var i = 0; i < data.length; i++) {\n    xValues.push(data[i].x);\n    yValues.push(data[i].y);\n    zValues.push(data[i].z);\n    magnitudeValues.push(data[i].magnitude);\n}\n\n// Function to calculate mean\nfunction mean(values) {\n    var sum = values.reduce((a, b) => a + b, 0);\n    return sum / values.length;\n}\n\n// Function to calculate variance\nfunction variance(values, meanValue) {\n    return values.reduce((a, b) => a + Math.pow(b - meanValue, 2), 0) / values.length;\n}\n\n// Calculate statistics for each axis and magnitude\nvar meanX = mean(xValues);\nvar meanY = mean(yValues);\nvar meanZ = mean(zValues);\nvar meanMagnitude = mean(magnitudeValues);\n\nvar varianceX = variance(xValues, meanX);\nvar varianceY = variance(yValues, meanY);\nvar varianceZ = variance(zValues, meanZ);\nvar varianceMagnitude = variance(magnitudeValues, meanMagnitude);\n\nvar stdDevX = Math.sqrt(varianceX);\nvar stdDevY = Math.sqrt(varianceY);\nvar stdDevZ = Math.sqrt(varianceZ);\nvar stdDevMagnitude = Math.sqrt(varianceMagnitude);\n\nvar medianX = median(xValues);\nvar medianY = median(yValues);\nvar medianZ = median(zValues);\nvar medianMagnitude = median(magnitudeValues);\n\n// Add statistics to the message payload\nmsg.payload = {\n    mean: {\n        x: meanX.toFixed(2),\n        y: meanY.toFixed(2),\n        z: meanZ.toFixed(2),\n        magnitude: meanMagnitude.toFixed(2)\n    },\n    median: {\n        x: medianX.toFixed(2),\n        y: medianY.toFixed(2),\n        z: medianZ.toFixed(2),\n        magnitude: medianMagnitude.toFixed(2)\n    },\n    variance: {\n        x: varianceX.toFixed(2),\n        y: varianceY.toFixed(2),\n        z: varianceZ.toFixed(2),\n        magnitude: varianceMagnitude.toFixed(2)\n    },\n    stdDev: {\n        x: stdDevX.toFixed(2),\n        y: stdDevY.toFixed(2),\n        z: stdDevZ.toFixed(2),\n        magnitude: stdDevMagnitude.toFixed(2)\n    }\n};\n\nreturn msg;\n",
    "outputs": 1,
    "timeout": 0,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 2390,
    "y": 680,
    "wires": [["7efea9ea8eac6714"]]
  },
  {
    "id": "7efea9ea8eac6714",
    "type": "ui_template",
    "z": "4bea5ea383b8ed08",
    "group": "7b778c48129e069b",
    "name": "",
    "order": 15,
    "width": 17,
    "height": 3,
    "format": "<table border=\"1\" style=\"width:100%; border-collapse: collapse;\">\n    <thead>\n        <tr>\n            <th>Acceleration Statistic</th>\n            <th>X</th>\n            <th>Y</th>\n            <th>Z</th>\n            <th>Magnitude</th>\n        </tr>\n    </thead>\n    <tbody>\n        <tr>\n            <td>Mean</td>\n            <td>{{msg.payload.mean.x}}</td>\n            <td>{{msg.payload.mean.y}}</td>\n            <td>{{msg.payload.mean.z}}</td>\n            <td>{{msg.payload.mean.magnitude}}</td>\n        </tr>\n        <tr>\n            <td>Median</td>\n            <td>{{msg.payload.median.x}}</td>\n            <td>{{msg.payload.median.y}}</td>\n            <td>{{msg.payload.median.z}}</td>\n            <td>{{msg.payload.median.magnitude}}</td>\n        </tr>\n        <tr>\n            <td>Variance</td>\n            <td>{{msg.payload.variance.x}}</td>\n            <td>{{msg.payload.variance.y}}</td>\n            <td>{{msg.payload.variance.z}}</td>\n            <td>{{msg.payload.variance.magnitude}}</td>\n        </tr>\n        <tr>\n            <td>Standard Deviation</td>\n            <td>{{msg.payload.stdDev.x}}</td>\n            <td>{{msg.payload.stdDev.y}}</td>\n            <td>{{msg.payload.stdDev.z}}</td>\n            <td>{{msg.payload.stdDev.magnitude}}</td>\n        </tr>\n    </tbody>\n</table>",
    "storeOutMessages": true,
    "fwdInMessages": true,
    "resendOnRefresh": true,
    "templateScope": "local",
    "className": "",
    "x": 2652,
    "y": 680,
    "wires": [[]]
  },
  {
    "id": "7b778c48129e069b",
    "type": "ui_group",
    "name": "Cold Path",
    "tab": "c67b592948628c69",
    "order": 2,
    "disp": true,
    "width": 17,
    "collapse": false,
    "className": ""
  },
  {
    "id": "c67b592948628c69",
    "type": "ui_tab",
    "name": "Cold Path Dashboard",
    "icon": "dashboard",
    "order": 2,
    "disabled": false,
    "hidden": false
  }
]
